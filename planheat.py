# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PlanHeat
                                 A QGIS plugin
 The PlanHeat tool is the heart of the PLANHEAT project.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-04-25
        git sha              : $Format:%H$
        copyright            : (C) 2019 by PlanHeat consortium
        email                : stefano.barberis@rina.org
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication,pyqtSignal
from PyQt5.QtGui import QIcon, QMovie, QPixmap
from PyQt5.QtWidgets import QAction, QFileDialog, QTableWidgetItem, QHeaderView, QTableWidget, QSplashScreen, QApplication, QMessageBox
from PyQt5 import QtCore, QtGui

# Initialize Qt resources from file resources.py
from .ui.resources import *
# Import the code for the dialog
from .ui.planheat_dialog import PlanHeatDialog
from .ui.project_tools_dialogs import ProjectCreateDialog, ProjectDuplicateDialog, ProjectDeleteDialog
import os.path
# Import plugin objects
from . import config
from .planheatproject import PlanHeatProject
# Import utils
import logging
import sys
import shutil
# Import submodules
from .PlanheatMappingModule.planheat_integration import PlanheatIntegration
from .PlanheatMappingModule import master_mapping_config
from .planning_and_simulation_modules import master_planning_config
from .planning_and_simulation_modules.planning_and_simulation_modules import PlanningAndSimulationModules
# Import 
from .PlanheatMappingModule.shapeCreator.shapeCreator import ShapeCreator
from .PlanheatMappingModule.pointCreator.pointCreator import PointCreator


class PlanHeat:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Set up logger
        self.logger = logging.getLogger(__name__)
        self.set_up_logger()
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'PlanHeat_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Create the dialog (after translation) and keep reference
        self.dlg = PlanHeatDialog()
        self.connect_buttons()

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&PlanHeat project')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'PlanHeat')
        self.toolbar.setObjectName(u'PlanHeat')

        # Sub plugins references:
        self.mapping_module = None
        self.planning_module = None

        # Useful objects
        self.current_projects = None
        self.current_php = None
        self.php_planning_and_simulation_in_progress = None

        self.init_splashscreen()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('PlanHeat', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        file_dir_path = os.path.dirname(os.path.realpath(__file__))
        ui_path = os.path.join(file_dir_path, "ui")
        icon_path = os.path.join(ui_path, "icon.png")
        self.add_action(
            icon_path,
            text=self.tr(u'PlanHeat'),
            callback=self.run,
            parent=self.iface.mainWindow())

        file_dir_path = os.path.dirname(os.path.realpath(__file__))
        icon_path_sc = os.path.join(file_dir_path, "ui", "images", "icon_sc.png")
        self.add_action(
            icon_path_sc,
            text='&Create shape',
            callback=self.runShapeCreator,
            parent=self.iface.mainWindow())

        file_dir_path = os.path.dirname(os.path.realpath(__file__))
        icon_path_pc = os.path.join(file_dir_path, "ui", "images", "icon_pc.png")
        self.add_action(
            icon_path_pc,
            text='&Create point',
            callback=self.runPointCreator,
            parent=self.iface.mainWindow())


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&PlanHeat'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar


    def run(self):
        """Run method that performs all the real work"""
        # show the dialog
        self.dlg.show()
        # Look for existing projects
        self.update_projects_combobox()

    def runShapeCreator(self):
        if self.mapping_module is not None:
            if len(self.mapping_module.actions) < 3:
                self.mapping_module.actions = [None]*3
            if self.mapping_module.actions[1] is None:
                self.mapping_module.actions[1] = self.actions[1]
            ShapeCreator.select(self.mapping_module)

    def runPointCreator(self):
        if self.mapping_module is not None:
            if len(self.mapping_module.actions) < 3:
                self.mapping_module.actions = [None]*3
            if self.mapping_module.actions[2] is None:
                self.mapping_module.actions[2] = self.actions[2]
            PointCreator.select(self.mapping_module)


    def connect_buttons(self):
        """Connect all UI buttons to a python function"""
        self.dlg.pushButton_close.clicked.connect(self.main_close)
        self.dlg.pushButton_CMMB.clicked.connect(lambda : self.main_start(mode="CMMB"))
        self.dlg.pushButton_CMMF.clicked.connect(lambda : self.main_start(mode="CMMF"))
        self.dlg.pushButton_DMM.clicked.connect(lambda : self.main_start(mode="DMM"))
        self.dlg.pushButton_SMM.clicked.connect(lambda : self.main_start(mode="SMM"))
        self.dlg.pushButton_CPM.clicked.connect(lambda : self.main_start(mode="CPM"))
        self.dlg.pushButton_DPM.clicked.connect(lambda : self.main_start(mode="DPM"))
        

        self.dlg.pushButton_create_project.clicked.connect(self.create_project)
        self.dlg.pushButton_duplicate_project.clicked.connect(self.duplicate_project)
        self.dlg.pushButton_delete_project.clicked.connect(self.delete_project)
        self.dlg.pushButton_export_project.clicked.connect(self.export_project)
        self.dlg.pushButton_import_project.clicked.connect(lambda: self.import_project(None))
        self.dlg.pushButton_import_default_test_case.clicked.connect(self.init_antwerp_demo_case)
        self.dlg.comboBox_project_name.currentIndexChanged.connect(self.set_current_planheat_project)

        self.dlg.closeMapping.connect(self.close_mapping_module)
        self.dlg.closePlanning.connect(self.close_planning_module)

    def main_start(self, mode):
        # mode in ["CMMB", "CMMF", "SMM", "DMM", "CPM", "DPM"]
        if mode in ["CMMB", "CMMF", "SMM", "DMM"]:
            self.logger.info("Starting mapping module")
            self.mapping_module = PlanheatIntegration(self.iface, self.dlg)
            self.set_mapping_config()
            self.dlg.hide()
            self.mapping_module.run()
            self.mapping_module.onStart(mode=mode)
            self.update_module_availability()
        elif mode in ["DPM", "CPM"]:
            self.set_planning_config()
            planning_folder = self.current_php.get_planning_directory_path()

            # we don't want to restart from scratch the planning and simulation module if it is already in progress
            if True:#self.current_php.working_directory_name != self.php_planning_and_simulation_in_progress:
                self.planning_module = PlanningAndSimulationModules(self.iface, self.dlg, work_folder=planning_folder)
                self.php_planning_and_simulation_in_progress = self.current_php.working_directory_name
                self.planning_module.first_start = True
                if mode == "CPM":
                    self.logger.info("Starting planning and simulation module (City mode)")
                    self.planning_module.first_start_city = True
                elif mode == "DPM":
                    self.logger.info("Starting planning and simulation module (District mode)")
                    self.planning_module.first_start_district = True
                self.dlg.hide()
                self.planning_module.run()
            else:
                self.dlg.hide()
                if mode == "CPM":
                    self.logger.info("Return to planning and simulation module (City mode)")
                    self.planning_module.openCity()
                if mode == "DPM":
                    self.logger.info("Return to planning and simulation module (District mode)")
                    self.planning_module.openDistrict()
            self.update_module_availability()

    def main_close(self):
        self.dlg.close()

    def set_mapping_config(self):
        master_mapping_config.CURRENT_PROJECT_NAME = self.current_php.get_name()
        master_mapping_config.CURRENT_MAPPING_DIRECTORY = self.current_php.get_mapping_directory_path()
        master_mapping_config.CURRENT_DB_CMM_SMM_FILE_PATH = self.current_php.get_mapping_cmm_smm_db_path()
        master_mapping_config.CURRENT_PROJECT_ID = self.current_php.infos[config.PROJECT_ID_KEY]

    def set_planning_config(self):
        master_planning_config.CURRENT_PROJECT_NAME = self.current_php.get_name()
        master_planning_config.CURRENT_MAPPING_DIRECTORY = self.current_php.get_mapping_directory_path()
        master_planning_config.CURRENT_PLANNING_DIRECTORY = self.current_php.get_planning_directory_path()
        master_planning_config.CURRENT_DB_CMM_SMM_FILE_PATH = self.current_php.get_mapping_cmm_smm_db_path()
        master_planning_config.CURRENT_PROJECT_ID = self.current_php.infos[config.PROJECT_ID_KEY]

    def set_up_logger(self):
        # Placeholder to have a 'write' method
        class Printer:
            def write(self, x):
                print(x)

        self.logger = logging.getLogger()
        self.logger.setLevel(logging.INFO)
        output_stream = sys.stdout if sys.stdout is not None else Printer()
        stream_handler = logging.StreamHandler(output_stream)
        formatter = logging.Formatter('%(asctime)s :: %(levelname)s :: %(message)s')
        stream_handler.setFormatter(formatter)
        stream_handler.setLevel(logging.DEBUG)
        self.logger.addHandler(stream_handler)

    def scan_for_projects(self):
        """Scan appdata directory to find project to show in the combobox."""
        path = PlanHeatProject.WORKING_PATH
        projects = []
        self.logger.info(path)
        for d in os.listdir(path):
            directory_path = os.path.join(path, d)
            if not os.path.isdir(directory_path):
                continue
            info_file_path = os.path.join(directory_path, config.PROJECT_INFO_JSON_NAME)
            if not os.path.exists(info_file_path):
                continue
            infos = PlanHeatProject.read_info(info_file_path)
            if infos is None or (not PlanHeatProject.info_is_valid(infos)):
                continue
            projects.append(infos)
        return projects

    def update_projects_combobox(self):
        """Update dialog combobox to show existing projects."""
        projects = self.scan_for_projects()
        if len(projects) == 0:  # Add the demo test case only if there is no project
            self.init_antwerp_demo_case()
            projects = self.scan_for_projects()
        projects = sorted(projects, key=lambda i: PlanHeatProject.get_creation_date(i), reverse=True)
        self.dlg.comboBox_project_name.clear()
        self.current_projects = dict()
        for i, infos in enumerate(projects):
            project_name = infos.get(config.PROJECT_NAME_KEY, config.PROJECT_NAME_DEFAULT)
            project_creation_date = str(infos.get(config.PROJECT_CREATION_DATE_KEY, ""))
            self.dlg.comboBox_project_name.addItem("%s (%s)" % (str(project_name), project_creation_date))
            self.current_projects[i] = infos
        self.set_current_planheat_project()
        self.update_buttons_activation()

    def init_antwerp_demo_case(self):
        """This method imports the antwerp test case in the current projects."""
        antwerp_test_case_path = os.path.join(os.path.dirname(os.path.realpath(__file__)),
                                              config.PROJECTS_CLEAN_DATA_DIR,
                                              config.ANTWERP_TEST_CASE_FILE_NAME)
        self.import_project(antwerp_test_case_path)

    def update_table_infos(self):
        path = PlanHeatProject.WORKING_PATH
        if self.current_php is not None:
            directory_path = os.path.join(path, self.current_php.infos[config.PROJECT_ID_KEY])
            info_file_path = os.path.join(directory_path, config.PROJECT_INFO_JSON_NAME)
        else:
            self.dlg.tableWidget_project_infos.setRowCount(0)
            return
        infos = PlanHeatProject.read_info(info_file_path)
        self.dlg.tableWidget_project_infos.setEditTriggers(QTableWidget.NoEditTriggers)
        self.dlg.tableWidget_project_infos.setRowCount(0)
        self.dlg.tableWidget_project_infos.setColumnCount(2)
        vheader = self.dlg.tableWidget_project_infos.verticalHeader()
        vheader.setVisible(False)
        hheader = self.dlg.tableWidget_project_infos.horizontalHeader()
        hheader.setVisible(False)
        hheader.setSectionResizeMode(0, QHeaderView.ResizeToContents)
        hheader.setSectionResizeMode(1, QHeaderView.Stretch)
        for i in config.KEYS_TO_SHOW:
            if i in infos:
                nb_rows = self.dlg.tableWidget_project_infos.rowCount()
                self.dlg.tableWidget_project_infos.insertRow(nb_rows)
                vheader.setSectionResizeMode(nb_rows, QHeaderView.ResizeToContents)
                self.dlg.tableWidget_project_infos.setItem(nb_rows, 0, QTableWidgetItem(str(i)))
                self.dlg.tableWidget_project_infos.setItem(nb_rows, 1, QTableWidgetItem(str(infos[i])))


    def create_project(self):
        self.logger.info("Creating project")
        pcd = ProjectCreateDialog(parent=self.dlg)
        result = pcd.exec()
        if result:
            project_name = pcd.projectNameLineEdit.text()
            project_desc = pcd.descriptionLineEdit.text()
            infos = {config.PROJECT_NAME_KEY: project_name,
                     config.PROJECT_DESCRIPTION_KEY: project_desc}
            self.show_splashscreen()
            pp = PlanHeatProject(infos)
            self.hide_splashscreen()
            self.update_projects_combobox()

    def set_current_planheat_project(self):
        self.current_php = self.get_current_planheat_project()
        if self.current_php is not None:
            self.update_table_infos()
            self.update_module_availability()

    def get_current_planheat_project(self):
        current_php_index = self.dlg.comboBox_project_name.currentIndex()
        if current_php_index in self.current_projects:
            return PlanHeatProject.load(self.current_projects[current_php_index])
        else:
            return None

    def duplicate_project(self):
        self.logger.info("Duplicating project")
        if self.current_php is None:
            return
        pdd = ProjectDuplicateDialog(parent=self.dlg)
        pdd.projectNameLineEdit.setText(self.current_php.infos[config.PROJECT_NAME_KEY])
        result = pdd.exec()
        if result:
            new_project_name = pdd.projectNameLineEdit.text()
            new_php = self.current_php.duplicate()
            new_php.infos[config.PROJECT_NAME_KEY] = new_project_name
            new_php.serialize()
            self.update_projects_combobox()
            self.update_table_infos()

    def delete_project(self):
        self.logger.info("Deleting project")
        if self.current_php is None:
            return
        pdd = ProjectDeleteDialog(parent=self.dlg)
        result = pdd.exec()
        if result:
            self.current_php.tear_down()
            self.current_php = None
            self.update_projects_combobox()
            self.update_table_infos()
            self.update_module_availability()


    def export_project(self):
        self.logger.info("Exporting project")
        if self.current_php is None:
            return
        path = QFileDialog.getSaveFileName(filter="Compressed file (*.zip)")
        if path == ('', ''):
            return
        if isinstance(path, tuple):
            path = path[0]
        file_name, file_ext = os.path.splitext(path)
        if file_ext == ".zip":
            path = file_name
        # Zipping the working directory
        self.show_splashscreen()
        shutil.make_archive(path, 'zip', root_dir=self.current_php.get_full_working_path())
        self.hide_splashscreen()

        self.iface.messageBar().pushMessage("Success",
                                            "Project '%s' exported to '%s'" % (self.current_php.get_name(), str(path) + '.zip'),
                                            level=3)
        # TODO: serialize the mapping & planning modules before


    def import_project(self, path=None):
        """Import an existing project from a zip file. If the path is not given, it is asked to the user from an UI."""
        self.logger.info("Importing project")
        if path is None:
            path = QFileDialog.getOpenFileName(filter="Compressed file (*.zip)")
            if isinstance(path, tuple):
                path = path[0]
        if os.path.exists(path):
            self.show_splashscreen()
            self.clean_directory(PlanHeatProject.TEMP_WORKING_PATH)
            shutil.unpack_archive(path, extract_dir=PlanHeatProject.TEMP_WORKING_PATH, format='zip')
            if not PlanHeatProject.directory_is_valid(PlanHeatProject.TEMP_WORKING_PATH):
                self.hide_splashscreen()
                self.iface.messageBar().pushMessage("Error",
                                                    "Impossible to read project from file '%s' (missing files)" % str(path),
                                                    level=1)
                self.clean_directory(PlanHeatProject.TEMP_WORKING_PATH)
            else:
                php = PlanHeatProject.deserialize(PlanHeatProject.TEMP_WORKING_PATH)
                self.hide_splashscreen()
                if php is None:
                    message_params = ("Error", "Impossible to read project from file '%s' (corrupted data)" % str(path))
                    level = 1
                else:
                    message_params = ("Success", "Project '%s' imported" % (php.get_name()))
                    level = 3
                # Important to clean the temp directory, otherwise it will be considered as a project directory
                self.clean_directory(PlanHeatProject.TEMP_WORKING_PATH)
                self.iface.messageBar().pushMessage(*message_params, level=level)
                self.update_projects_combobox()



    @staticmethod
    def clean_directory(dir: str):
        """Remove all files and directories in a given directory."""
        if not os.path.exists(dir):
            parent_dir = os.path.join(dir, "..")
            if os.path.exists(parent_dir):
                os.mkdir(dir)
            return
        shutil.rmtree(dir)
        os.mkdir(dir)


    def update_buttons_activation(self):
        if self.current_php is None:
            current_php_is_set = False
        else:
            current_php_is_set = True
        self.dlg.pushButton_duplicate_project.setEnabled(current_php_is_set)
        self.dlg.pushButton_delete_project.setEnabled(current_php_is_set)
        self.dlg.pushButton_export_project.setEnabled(current_php_is_set)
        #self.dlg.pushButton_start.setEnabled(current_php_is_set) # TODO: uncomment

    def update_module_availability(self):
        #self.dlg.pushButton_CPM.setEnabled(True)
        #self.dlg.pushButton_DPM.setEnabled(True)
        self.dlg.pushButton_DPM.setEnabled(self.check_District_Planning_available())
        self.dlg.pushButton_CPM.setEnabled(self.check_City_Planning_available())
        self.dlg.pushButton_CMMF.setEnabled(self.check_City_Mapping_Future_available())
        
        self.dlg.pushButton_CMMB.setEnabled(self.current_php is not None)
        self.dlg.pushButton_DMM.setEnabled(self.current_php is not None)
        self.dlg.pushButton_SMM.setEnabled(self.current_php is not None)

    def close_mapping_module(self):
        self.logger.info("Closing mapping module")
        self.update_module_availability()

    def close_planning_module(self):
        self.logger.info("Closing planning module")
        self.update_module_availability()

    def check_District_Planning_available(self):
        if self.current_php is not None:
            directory = os.path.join(self.current_php.get_full_working_path(), config.MAPPING_DIRECTORY_NAME)
        else:
            return False

        # DMM output
        DMM_mandatory_files = []
        DMM_mandatory_files.append(config.DMM_PREFIX + ".shp")
        DMM_mandatory_files.append(config.DMM_PREFIX + config.DMM_HOURLY_SUFFIX + ".csv")
        DMM_mandatory_files.append(config.DMM_PREFIX + config.DMM_FUTURE_SUFFIX + ".shp")
        DMM_mandatory_files.append(config.DMM_PREFIX + config.DMM_FUTURE_SUFFIX + config.DMM_HOURLY_SUFFIX + ".csv")
        DMM_mandatory_files.append(config.DMM_PREFIX + ".scn")

        if not config.DMM_FOLDER in os.listdir(directory):
            return False
        DMM_files = os.listdir(os.path.join(directory, config.DMM_FOLDER))
        for file in DMM_mandatory_files:
            if not file in DMM_files:
                return False

        # SMM output
        if not config.SMM_FOLDER in os.listdir(directory):
            return False

        csv_ok = "planheat_result_2.csv" in os.listdir(os.path.join(directory, config.SMM_FOLDER))

        #tif_ok, shp_ok = False, False
        #shp_ok = "layer.shp" in os.listdir(os.path.join(directory, "SMM"))
        #tif_ok = len([f for f in os.listdir(os.path.join(directory, "SMM")) if f.endswith(".tif")]) > 0
        
        return csv_ok#tif_ok and shp_ok

    def check_City_Planning_available(self):
        if self.current_php is not None:
            directory = os.path.join(self.current_php.get_full_working_path(), config.MAPPING_DIRECTORY_NAME)
        else:
            return False

        if not config.CMM_BASELINE_FOLDER in os.listdir(directory):
            return False
        # TODO: need to check for json file

        # SMM output
        if not config.SMM_FOLDER in os.listdir(directory):
            return False

        csv_ok = "planheat_result_2.csv" in os.listdir(os.path.join(directory, config.SMM_FOLDER))
        
        return csv_ok

    def check_City_Mapping_Future_available(self):
        if self.current_php is not None:
            directory = os.path.join(self.current_php.get_full_working_path(), config.PLANNING_DIRECTORY_NAME)
        else:
            return False

        if not config.FUTURE_FOLDER in os.listdir(directory):
            return False

        csv_ok = False
        for f in os.listdir(os.path.join(directory, config.FUTURE_FOLDER)):
            if f.endswith(".csv"):
                csv_ok = True 

        return csv_ok

    def init_splashscreen(self):
        file_dir_path = os.path.dirname(os.path.realpath(__file__))
        icon_path = os.path.join(file_dir_path, "ui", "images", "loading.png")
        self.splash = QSplashScreen(QtGui.QPixmap(icon_path), QtCore.Qt.WindowStaysOnTopHint)
        self.splash.setWindowFlags(QtCore.Qt.WindowStaysOnTopHint | QtCore.Qt.FramelessWindowHint)
        self.splash.setEnabled(False)

    def show_splashscreen(self):
        self.splash.show()
        QApplication.processEvents()
    def hide_splashscreen(self):
        self.splash.hide()
        QApplication.processEvents()
